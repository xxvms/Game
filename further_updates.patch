Index: Game_map.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Game_map.cpp	(revision 2c9cde5b95434d011a9526c87c62170ff2fa8527)
+++ Game_map.cpp	(revision )
@@ -35,12 +35,12 @@
 void Game_map::Game_victory() {
     victory = {
             "===========================================================================================================",
-            "              Congratulations the mighty warrior you have managed to escape from the dungeons!             ",
+            "*      #################################################################################                  *",
             "===========================================================================================================",
 
     };
+    // Congratulations the mighty warrior you have managed to escape from the dungeons!
 }
-
 rang::fg get_color_for(char c){
     switch (c){
         case 'X':
@@ -76,9 +76,16 @@
     }
 }
 
-std::ostream& Game_map::print_victory(){
+void Game_map::print_victory(){
 
-    return std::cout << rang::style::bold<< rang::style::crossed << "you have won!!!" << rang::style::reset;
+    for (auto& line : victory){
+        for (auto& c: line){
+            std::cout << rang::bg::red << rang::fgB::green << rang::style::reset << get_color_for(c) << c << rang::style::reset;
+        }
+        std::cout << '\n';
+    }
+    //std::cout << rang::style::bold<< rang::style::crossed << "you have won!!!" << rang::style::reset;
+    //return false;
  }
 
 // function that allow to find location of the player on the map, variable i allows to find row and result refers to column
@@ -96,8 +103,9 @@
         x++;
     }
 }
+// function that provides coordinates for new move
 
-bool Game_map::player_moving(enum Cmove_direction direction, int steps){
+Game_map::Coordinates Game_map::new_position(enum Cmove_direction direction, int steps) {
 
     // using coord to perform one search to get value for x & y, this is better then:
     // size_t x = find_way().x; size_t y = find_way().y; in this line I am preforming search twice
@@ -106,60 +114,97 @@
     size_t x = coord.x;
     size_t y = coord.y;
 
+
     switch (direction){
 
         case Cmove_direction::up :
             system("clear");
             while (steps-- > 0){
-                if(map[coord.x - 1][coord.y] == ' ' || map[coord.x - 1][coord.y] == '.'){
-                    map[coord.x - 1][coord.y] = map[coord.x][coord.y];
-                    map[coord.x][coord.y] = '.';
-                } else if ( map[coord.x - 1][coord.y] == 'X'){
-                    print_victory();
-                }
-                coord = find_player();
+                return {x - 1,y};
+            }
+            break;
+        case Cmove_direction::down :
+            while(steps-- > 0) {
+                return {x + 1, y};
             }
-            print_base();
-            return false;
+            break;
+        case Cmove_direction::right :
+            while (steps-- >0){
+                    return {x, y + 1};
+            }
+            break;
+        case Cmove_direction::left :
+            while (steps-- > 0){
+                    return {x, y - 1};
+            }
+            break;
+    }
+}
+
+bool Game_map::check_move(enum Cmove_direction direction, int steps, Game_map::Coordinates current_xy,
+                          Game_map::Coordinates new_xy) {
+    switch (direction){
+
+        case Cmove_direction::up :
+            system("clear");
+            while (steps-- > 0) {
+                return map[new_xy.x][new_xy.y] == ' ' || map[new_xy.x][new_xy.y] == '.';
+            }
+            break;
+        case Cmove_direction::down :
+            while(steps-- > 0) {
+                return map[new_xy.x][new_xy.y] == ' ' || map[new_xy.x][new_xy.y] == '.';
+            }
+            break;
+        case Cmove_direction::right :
+            while (steps-- >0){
+                return map[new_xy.x][new_xy.y] == ' ' || map[new_xy.x][new_xy.y] == '.';
+            }
+            break;
+        case Cmove_direction::left :
+            while (steps-- > 0){
+                return map[new_xy.x][new_xy.y] == ' ' || map[new_xy.x][new_xy.y] == '.';
+            }
+            break;
+    }
+
+    return false;
+}
+void Game_map::player_moving(enum Cmove_direction direction, int steps, Game_map::Coordinates find_player, Game_map::Coordinates new_position){
+
+
+    switch (direction){
+
+        case Cmove_direction::up :
+            system("clear");
+            while (steps-- > 0){
+                map[new_position.x][new_position.y] = map[find_player.x][find_player.y];
+                map[find_player.x -1 ][find_player.y] = '.';
+            }
+            print_base();
             break;
         case Cmove_direction::down :
             while(steps-- > 0) {
-                if (map[coord.x + 1][coord.y] == ' ' || map[coord.x + 1][coord.y] == '.' ){
-                    map[coord.x + 1][coord.y] = map[coord.x][coord.y];
-                    map[coord.x][coord.y] = '.';
-                } else if (map[coord.x + 1][coord.y] == 'X'){
-                    print_victory();
-                }
-                print_base();
-                coord = find_player();
-            }
-            return false;
+                map[new_position.x][new_position.y] = map[find_player.x][find_player.y];
+                map[find_player.x + 1][find_player.y] = '.';
+            }
+            print_base();
             break;
         case Cmove_direction::right :
             while (steps-- >0){
-                if (map[coord.x][coord.y + 1] == ' '|| map[coord.x][coord.y + 1] == '.'){
-                    map[coord.x][coord.y + 1] = map[coord.x][coord.y];
-                    map[coord.x][coord.y] = '.';
-                } else if(map[coord.x][coord.y + 1] == 'X'){
-                    print_victory();
-                }
-                print_base();
-                coord = find_player();
-            }
-            return true;
+                map[new_position.x][new_position.y] = map[find_player.x][find_player.y];
+                map[find_player.x][find_player.y + 1] = '.';
+            }
+            print_base();
             break;
         case Cmove_direction::left :
             while (steps-- > 0){
-                if (map[coord.x][coord.y - 1] == ' '|| map[coord.x][coord.y - 1] == '.' ){
-                    map[coord.x][coord.y - 1] = map[coord.x][coord.y];
-                    map[coord.x][coord.y] = '.';
-                } else if (map[coord.x][coord.y + 1] == 'X'){
-                    print_victory();
-                }
-                print_base();
-                coord = find_player();
-            }
-            return true;
+                map[new_position.x][new_position.y] = map[find_player.x][find_player.y];
+                map[find_player.x][find_player.y - 1] = '.';
+            }
+            print_base();
             break;
     }
 }
+
+
Index: Game_map.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Game_map.h	(revision 2c9cde5b95434d011a9526c87c62170ff2fa8527)
+++ Game_map.h	(revision )
@@ -18,7 +18,6 @@
 private:
     std::vector<std::string> map;
     std::vector<std::string> victory;
-    int end_of_game = 0;
 
 public:
 
@@ -32,12 +31,18 @@
     // function that allow to find location of the player on the map, variable i allows to find row and result refers to column
     Coordinates find_player();
 
+    // function that provides coordinates for new move
+    Coordinates new_position(enum Cmove_direction direction, int steps);
+
+    // function to validate move
+    bool check_move(enum Cmove_direction direction, int steps, Game_map::Coordinates current_xy, Game_map::Coordinates new_xy);
+
     // executing user move after move has been verified and its valid
-    bool player_moving(enum Cmove_direction, int steps);
+    void player_moving(enum Cmove_direction, int steps, Game_map::Coordinates current_position, Game_map::Coordinates new_position);
 
     // function to print map
     void print_base();
-    std::ostream& print_victory();
+    void print_victory();
 
 };
 
Index: main.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- main.cpp	(revision 2c9cde5b95434d011a9526c87c62170ff2fa8527)
+++ main.cpp	(revision )
@@ -30,8 +30,6 @@
     first.print_base();
     first.find_player();
 
-    bool game = true;
-
     do {
         std::cout << "Please provide direction (up/down/right/left): ";
         std::string choice;
@@ -39,39 +37,47 @@
 
         switch (menu(choice)) {
 
-            case 1:
+            case 1:{
+                std::cout << "Going Up " << '\n';
                 Cmove_direction direction_up;
                 direction_up = static_cast<Cmove_direction>(0);
-                std::cout << "Going Up " << '\n';
-                game = first.player_moving(direction_up, steps());
+                auto new_position = first.new_position(direction_up, steps());
+                first.player_moving(direction_up, steps(), first.find_player(), new_position);
                 break;
+            }
 
-            case 2:
+            case 2:{
                 std::cout << "Going Down" << '\n';
                 Cmove_direction direction_down;
                 direction_down= static_cast<Cmove_direction>(1);
-                game = first.player_moving(direction_down, steps());
+                auto new_position = first.new_position(direction_down, steps());
+                first.player_moving(direction_down, steps(), first.find_player(), new_position);
                 break;
+            }
 
-            case 3:
+            case 3:{
                 std::cout << "Going Right" << '\n';
                 Cmove_direction direction_right;
                 direction_right = static_cast<Cmove_direction>(2);
-                game = first.player_moving(direction_right, steps());
+                auto new_position = first.new_position(direction_right, steps());
+                first.player_moving(direction_right,  steps(), first.find_player(), new_position);
                 break;
+            }
 
-            case 4:
+            case 4:{
                 std::cout << "Going Left" << '\n';
                 Cmove_direction direction_left;
                 direction_left = static_cast<Cmove_direction>(3);
-                game = first.player_moving(direction_left, steps());
+                auto new_position = first.new_position(direction_left, steps());
+                first.player_moving(direction_left, steps(), first.find_player(), new_position);
                 break;
+            }
 
             default:
                 std::cout << "Not going :( select valid choice!" << '\n';
                 break;
         }
-    } while (game);
+    } while (true); //!first.print_victory() == 1);
 
     return 0;
 
